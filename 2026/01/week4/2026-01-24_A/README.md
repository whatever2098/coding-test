## 2026-01-24
파일 생성일

BFS 최단 거리 문제 리뷰

# BOJ2178 미로 탐색

## 문제 요약
<details>
  <summary>문제 설명</summary>

  
  막힌 칸이 0이고 열린 칸이 1인 N * M의 맵이 있을 때, 
  (1, 1) ~ (N, M) 까지의 최단 거리(칸 수)

</details>

---
## 핵심 아이디어

<details>
  <summary>아이디어 펼치기</summary>
최단 거리 문제여서 다익스트라 문제와 헷갈릴 수 있다. 하지만 문제 조건을 보면
  
"한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다."

즉, vertex간 거리(edge)가 1로 일정한데, 
**이 경우 BFS 탐색 순서가 이미 최단 거리 순서이므로**
BFS로 푸는 문제이다.
</details>

---
## 구현 흐름

<details>
  <summary>구현 단계</summary>

1. 미로를 입력받아 board 배열에 저장<br>

    - 입력은 공백 없이 문자열로 들어오므로
   문자 '0', '1'을 숫자로 변환하여 저장한다.

2. dist[x][y] 배열을 선언

   - (1,1)에서 (x,y)까지의 최단 거리(칸 수) 저장
   - dist == 0 → 아직 방문하지 않은 칸

3. BFS 시작

   - dist[1][1] = 1 방문 체크 후 시작점 (1,1)을 큐에 넣는다.

4. 큐에서 현재 칸을 꺼내 상/하/좌/우 탐색

   - 범위를 벗어나면 무시
   - 벽(0)이면 무시
   - 이미 방문한 칸(dist != 0)이면 무시

5. 이동 가능한 칸은
```cpp
dist[nx][ny] = dist[x][y] + 1
```
로 거리 갱신 후에 큐에 삽입

6. BFS 종료 후 dist[N][M] 출력
</details>

---
## 주의/실수 포인트

<details>
  <summary>포인트 펼치기</summary>

  1️⃣ 방문 개수(cnt)를 세면 안 됨

- 이 문제는 “얼마나 많은 칸을 방문했는가”가 아니라
  **“목적지까지의 최단 거리”**를 묻는 문제이다.

- 따라서 cnt++ 방식은 오답.

2️⃣ visit 배열을 bool로만 쓰면 안 됨

- 방문 여부만 체크하면 거리 정보가 남지 않는다.

- visit 대신 dist 배열에 거리 값을 저장하는 것이 핵심.

3️⃣ 입력 형식 주의

- 미로는 101111 같은 문자열 형태로 입력된다.

- cin >> board[i][j] 방식으로 받으면 안 된다.

4️⃣ BFS에서 방문 체크 시점

- **큐에 넣는 순간 방문(dist)을 체크해야 한다.**

- 꺼낼 때 체크하면 같은 칸이 여러 번 큐에 들어갈 수 있다.

</details>

---
## 시간 복잡도

<details>
  <summary>빅오</summary>

  - 각 칸은 최대 한 번씩만 방문

  - 각 칸에서 4방향 탐색

시간 복잡도:

𝑂(N x M)
  
</details>

---
## C++ 코드

<details>
  <summary>코드 링크</summary>
  
  [전체 코드](BOJ2178_미로_탐색.cpp)
</details>

